"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PineconeStore = void 0;
const uuid_1 = require("uuid");
const base_1 = require("./base");
const document_1 = require("../document");
class PineconeStore extends base_1.VectorStore {
    constructor(pineconeClient, embeddings, textKey = "text") {
        super(embeddings);
        Object.defineProperty(this, "textKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "pineconeClient", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.pineconeClient = pineconeClient;
        this.embeddings = embeddings;
        this.textKey = textKey;
    }
    async addDocuments(documents, ids) {
        const texts = documents.map(({ pageContent }) => pageContent);
        return this.addVectors(await this.embeddings.embedDocuments(texts), documents, ids);
    }
    async addVectors(vectors, documents, ids) {
        const documentIds = ids == null ? documents.map(() => (0, uuid_1.v4)()) : ids;
        return this.pineconeClient.upsert({
            vectors: vectors.map((values, idx) => ({
                id: documentIds[idx],
                metadata: {
                    ...documents[idx].metadata,
                    [this.textKey]: documents[idx].pageContent,
                },
                values,
            })),
        });
    }
    async similaritySearchVectorWithScore(query, k) {
        const results = await this.pineconeClient.query({
            topK: k,
            includeMetadata: true,
            vector: query,
        });
        const result = [];
        for (const res of results.matches) {
            const { [this.textKey]: pageContent, ...metadata } = res.metadata;
            result.push([new document_1.Document({ metadata, pageContent }), res.score]);
        }
        return result;
    }
    static async fromTexts(pineconeClient, texts, metadatas, embeddings, textKey = "text") {
        const docs = [];
        for (let i = 0; i < texts.length; i += 1) {
            const newDoc = new document_1.Document({
                pageContent: texts[i],
                metadata: metadatas[i],
            });
            docs.push(newDoc);
        }
        return PineconeStore.fromDocuments(pineconeClient, docs, embeddings, textKey);
    }
    static async fromDocuments(pineconeClient, docs, embeddings, textKey = "text") {
        const instance = new this(pineconeClient, embeddings, textKey);
        await instance.addDocuments(docs);
        return instance;
    }
    static async fromExistingIndex(pineconeClient, embeddings, textKey = "text") {
        const instance = new this(pineconeClient, embeddings, textKey);
        return instance;
    }
}
exports.PineconeStore = PineconeStore;
//# sourceMappingURL=pinecone.js.map