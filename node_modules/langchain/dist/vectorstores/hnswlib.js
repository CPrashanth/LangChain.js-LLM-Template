"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HNSWLib = void 0;
const promises_1 = __importDefault(require("fs/promises"));
const path_1 = __importDefault(require("path"));
const base_1 = require("./base");
const document_1 = require("../document");
const docstore_1 = require("../docstore");
let HierarchicalNSW = null;
try {
    // eslint-disable-next-line global-require,import/no-extraneous-dependencies
    ({ HierarchicalNSW } = require("hnswlib-node"));
}
catch (_a) {
    // ignore error
}
class HNSWLib extends base_1.SaveableVectorStore {
    constructor(args, embeddings, docstore, index) {
        super(embeddings);
        Object.defineProperty(this, "index", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "docstore", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "args", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.index = index;
        this.args = args;
        this.embeddings = embeddings;
        this.docstore = docstore;
    }
    async addDocuments(documents) {
        const texts = documents.map(({ pageContent }) => pageContent);
        return this.addVectors(await this.embeddings.embedDocuments(texts), documents);
    }
    async addVectors(vectors, documents) {
        if (vectors.length === 0) {
            return;
        }
        if (!this.index) {
            if (this.args.numDimensions === undefined) {
                this.args.numDimensions = vectors[0].length;
            }
            if (HierarchicalNSW === null) {
                throw new Error("Please install hnswlib-node as a dependency with, e.g. `npm install -S hnswlib-node`");
            }
            this.index = new HierarchicalNSW(this.args.space, this.args.numDimensions);
            this.index.initIndex(vectors.length);
        }
        // TODO here we could optionally normalise the vectors to unit length
        // so that dot product is equivalent to cosine similarity, like this
        // https://github.com/nmslib/hnswlib/issues/384#issuecomment-1155737730
        // While we only support OpenAI embeddings this isn't necessary
        if (vectors.length !== documents.length) {
            throw new Error(`Vectors and metadatas must have the same length`);
        }
        if (vectors[0].length !== this.args.numDimensions) {
            throw new Error(`Vectors must have the same length as the number of dimensions (${this.args.numDimensions})`);
        }
        const capacity = this.index.getMaxElements();
        const needed = this.index.getCurrentCount() + vectors.length;
        if (needed > capacity) {
            this.index.resizeIndex(needed);
        }
        const docstoreSize = this.docstore.count;
        for (let i = 0; i < vectors.length; i += 1) {
            this.index.addPoint(vectors[i], docstoreSize + i);
            this.docstore.add({ [docstoreSize + i]: documents[i] });
        }
    }
    async similaritySearchVectorWithScore(query, k) {
        if (!this.index) {
            throw new Error("Vector store not initialised yet. Try calling `addTexts` first.");
        }
        if (query.length !== this.args.numDimensions) {
            throw new Error(`Query vector must have the same length as the number of dimensions (${this.args.numDimensions})`);
        }
        if (k > this.index.getCurrentCount()) {
            const total = this.index.getCurrentCount();
            console.warn(`k (${k}) is greater than the number of elements in the index (${total}), setting k to ${total}`);
            // eslint-disable-next-line no-param-reassign
            k = total;
        }
        const result = this.index.searchKnn(query, k);
        return result.neighbors.map((docIndex, resultIndex) => [
            this.docstore.search(String(docIndex)),
            result.distances[resultIndex],
        ]);
    }
    async save(directory) {
        if (!this.index) {
            throw new Error("Vector store not initialised yet. Try calling `addTexts` first.");
        }
        console.log(this.docstore);
        console.log(JSON.stringify(this.docstore._docs.get("0")));
        await promises_1.default.mkdir(directory, { recursive: true });
        await Promise.all([
            this.index.writeIndex(path_1.default.join(directory, "hnswlib.index")),
            await promises_1.default.writeFile(path_1.default.join(directory, "args.json"), JSON.stringify(this.args)),
            await promises_1.default.writeFile(path_1.default.join(directory, "docstore.json"), JSON.stringify(Array.from(this.docstore._docs.entries()))),
        ]);
    }
    static async load(directory, embeddings) {
        if (HierarchicalNSW === null) {
            throw new Error("Please install hnswlib-node as a dependency with, e.g. `npm install -S hnswlib-node`");
        }
        const args = JSON.parse(await promises_1.default.readFile(path_1.default.join(directory, "args.json"), "utf8"));
        const index = new HierarchicalNSW(args.space, args.numDimensions);
        const [docstoreFiles] = await Promise.all([
            promises_1.default
                .readFile(path_1.default.join(directory, "docstore.json"), "utf8")
                .then(JSON.parse),
            index.readIndex(path_1.default.join(directory, "hnswlib.index")),
        ]);
        console.log(docstoreFiles);
        console.log(docstoreFiles._docs);
        const docstore = new docstore_1.InMemoryDocstore(new Map(docstoreFiles));
        return new HNSWLib(args, embeddings, docstore, index);
    }
    static async fromTexts(texts, metadatas, embeddings, docstore = new docstore_1.InMemoryDocstore()) {
        const docs = [];
        for (let i = 0; i < texts.length; i += 1) {
            const newDoc = new document_1.Document({
                pageContent: texts[i],
                metadata: metadatas[i],
            });
            docs.push(newDoc);
        }
        return HNSWLib.fromDocuments(docs, embeddings, docstore);
    }
    static async fromDocuments(docs, embeddings, docstore = new docstore_1.InMemoryDocstore()) {
        if (HierarchicalNSW === null) {
            throw new Error("Please install hnswlib-node as a dependency with, e.g. `npm install -S hnswlib-node`");
        }
        const args = {
            space: "ip", // dot product
        };
        const instance = new this(args, embeddings, docstore);
        await instance.addDocuments(docs);
        return instance;
    }
}
exports.HNSWLib = HNSWLib;
//# sourceMappingURL=hnswlib.js.map