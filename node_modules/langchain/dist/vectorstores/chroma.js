"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Chroma = void 0;
const uuid_1 = require("uuid");
const base_1 = require("./base");
const document_1 = require("../document");
let ChromaClient = null;
try {
    // eslint-disable-next-line global-require,import/no-extraneous-dependencies
    ({ ChromaClient } = require("chromadb"));
}
catch (_a) {
    // ignore error
}
class Chroma extends base_1.VectorStore {
    constructor(args, embeddings, index) {
        super(embeddings);
        Object.defineProperty(this, "index", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "args", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "collectionName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "url", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.index = index;
        this.args = args;
        this.embeddings = embeddings;
        this.collectionName = ensureCollectionName(args.collectionName);
        this.url = args.url || "http://localhost:8000";
    }
    async addDocuments(documents) {
        const texts = documents.map(({ pageContent }) => pageContent);
        await this.addVectors(await this.embeddings.embedDocuments(texts), documents);
    }
    async addVectors(vectors, documents) {
        if (vectors.length === 0) {
            return;
        }
        if (!this.index) {
            if (this.args.numDimensions === undefined) {
                this.args.numDimensions = vectors[0].length;
            }
            if (ChromaClient === null) {
                throw new Error("Please install chromadb as a dependency with, e.g. `npm install -S chromadb`");
            }
            this.index = new ChromaClient(this.url);
            try {
                await this.index.createCollection(this.collectionName);
            }
            catch (_a) {
                // ignore error
            }
        }
        if (vectors.length !== documents.length) {
            throw new Error(`Vectors and metadatas must have the same length`);
        }
        if (vectors[0].length !== this.args.numDimensions) {
            throw new Error(`Vectors must have the same length as the number of dimensions (${this.args.numDimensions})`);
        }
        const collection = await this.index.getCollection(this.collectionName);
        const docstoreSize = await collection.count();
        await collection.add(Array.from({ length: vectors.length }, (_, i) => (docstoreSize + i).toString()), vectors, documents.map(({ metadata }) => metadata), documents.map(({ pageContent }) => pageContent));
    }
    async similaritySearchVectorWithScore(query, k) {
        if (!this.index) {
            throw new Error("Vector store not initialised yet. Try calling `addTexts` first.");
        }
        const collection = await this.index.getCollection(this.collectionName);
        const result = await collection.query(query, k);
        const { ids, distances, documents, metadatas } = result;
        // ids comes back as a list of lists, so we need to flatten it
        const takeIds = ids[0];
        const results = [];
        for (let i = 0; i < takeIds.length; i += 1) {
            results.push([
                new document_1.Document({
                    pageContent: documents[i],
                    metadata: metadatas[i],
                }),
                distances[i],
            ]);
        }
        return results;
    }
    static async fromTexts(texts, metadatas, embeddings, collectionName, url) {
        const docs = [];
        for (let i = 0; i < texts.length; i += 1) {
            const newDoc = new document_1.Document({
                pageContent: texts[i],
                metadata: metadatas[i],
            });
            docs.push(newDoc);
        }
        return Chroma.fromDocuments(docs, embeddings, collectionName, url);
    }
    static async fromDocuments(docs, embeddings, collectionName, url) {
        if (ChromaClient === null) {
            throw new Error("Please install chromadb as a dependency with, e.g. `npm install -S chromadb`");
        }
        const args = {
            collectionName,
            url,
        };
        const instance = new this(args, embeddings);
        await instance.addDocuments(docs);
        return instance;
    }
}
exports.Chroma = Chroma;
function ensureCollectionName(collectionName) {
    if (!collectionName) {
        return `langchain-${(0, uuid_1.v4)()}`;
    }
    return collectionName;
}
//# sourceMappingURL=chroma.js.map