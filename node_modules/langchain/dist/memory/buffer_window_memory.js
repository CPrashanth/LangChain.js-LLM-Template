"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BufferWindowMemory = void 0;
const base_1 = require("./base");
const getInputValue = (inputValues) => {
    const keys = Object.keys(inputValues);
    if (keys.length === 1) {
        return inputValues[keys[0]];
    }
    throw new Error("input values have multiple keys, memory only supported when one key currently");
};
class BufferWindowMemory extends base_1.BaseMemory {
    constructor(fields) {
        var _a, _b, _c, _d;
        super();
        Object.defineProperty(this, "humanPrefix", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "Human"
        });
        Object.defineProperty(this, "aiPrefix", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AI"
        });
        Object.defineProperty(this, "memoryKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "history"
        });
        Object.defineProperty(this, "buffer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "k", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 5
        });
        this.humanPrefix = (_a = fields === null || fields === void 0 ? void 0 : fields.humanPrefix) !== null && _a !== void 0 ? _a : this.humanPrefix;
        this.aiPrefix = (_b = fields === null || fields === void 0 ? void 0 : fields.aiPrefix) !== null && _b !== void 0 ? _b : this.aiPrefix;
        this.memoryKey = (_c = fields === null || fields === void 0 ? void 0 : fields.memoryKey) !== null && _c !== void 0 ? _c : this.memoryKey;
        this.k = (_d = fields === null || fields === void 0 ? void 0 : fields.k) !== null && _d !== void 0 ? _d : this.k;
    }
    async loadMemoryVariables(_values) {
        const result = {
            [this.memoryKey]: this.buffer.slice(-this.k).join("\n\n"),
        };
        return result;
    }
    async saveContext(inputValues, outputValues) {
        const values = await outputValues;
        const human = `${this.humanPrefix}: ${getInputValue(inputValues)}`;
        const ai = `${this.aiPrefix}: ${getInputValue(values)}`;
        const newlines = [human, ai];
        this.buffer.push(`\n${newlines.join("\n")}`);
    }
}
exports.BufferWindowMemory = BufferWindowMemory;
//# sourceMappingURL=buffer_window_memory.js.map