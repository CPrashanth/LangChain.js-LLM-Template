"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnalyzeDocumentChain = void 0;
const index_1 = require("./index");
const text_splitter_1 = require("../text_splitter");
const util_1 = require("../util");
/**
 * Chain that combines documents by stuffing into context.
 * @augments BaseChain
 * @augments StuffDocumentsChainInput
 */
class AnalyzeDocumentChain extends index_1.BaseChain {
    constructor(fields) {
        var _a, _b, _c;
        super();
        Object.defineProperty(this, "inputKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "input_document"
        });
        Object.defineProperty(this, "outputKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "output_text"
        });
        Object.defineProperty(this, "combineDocumentsChain", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "textSplitter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.combineDocumentsChain = fields.combineDocumentsChain;
        this.inputKey = (_a = fields.inputKey) !== null && _a !== void 0 ? _a : this.inputKey;
        this.outputKey = (_b = fields.outputKey) !== null && _b !== void 0 ? _b : this.outputKey;
        this.textSplitter =
            (_c = fields.textSplitter) !== null && _c !== void 0 ? _c : new text_splitter_1.RecursiveCharacterTextSplitter();
    }
    get inputKeys() {
        return [this.inputKey];
    }
    async _call(values) {
        if (!(this.inputKey in values)) {
            throw new Error(`Document key ${this.inputKey} not found.`);
        }
        const { [this.inputKey]: doc, ...rest } = values;
        const currentDoc = doc;
        const currentDocs = this.textSplitter.createDocuments([currentDoc]);
        const newInputs = { input_documents: currentDocs, ...rest };
        const result = await this.combineDocumentsChain.call(newInputs);
        return result;
    }
    _chainType() {
        return "analyze_document_chain";
    }
    static async deserialize(data, values) {
        if (!("text_splitter" in values)) {
            throw new Error(`Need to pass in a text_splitter to deserialize AnalyzeDocumentChain.`);
        }
        const { text_splitter } = values;
        const SerializedCombineDocumentChain = (0, util_1.resolveConfigFromFile)("combine_document_chain", data);
        return new AnalyzeDocumentChain({
            combineDocumentsChain: await index_1.BaseChain.deserialize(SerializedCombineDocumentChain),
            textSplitter: text_splitter,
        });
    }
    serialize() {
        return {
            _type: this._chainType(),
            combine_document_chain: this.combineDocumentsChain.serialize(),
        };
    }
}
exports.AnalyzeDocumentChain = AnalyzeDocumentChain;
//# sourceMappingURL=analyze_documents_chain.js.map