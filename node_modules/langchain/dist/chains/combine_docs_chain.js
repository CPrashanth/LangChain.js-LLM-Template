"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MapReduceDocumentsChain = exports.StuffDocumentsChain = void 0;
const index_1 = require("./index");
const util_1 = require("../util");
/**
 * Chain that combines documents by stuffing into context.
 * @augments BaseChain
 * @augments StuffDocumentsChainInput
 */
class StuffDocumentsChain extends index_1.BaseChain {
    get inputKeys() {
        return [this.inputKey, ...this.llmChain.inputKeys];
    }
    constructor(fields) {
        var _a, _b, _c;
        super();
        Object.defineProperty(this, "llmChain", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "inputKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "input_documents"
        });
        Object.defineProperty(this, "outputKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "output_text"
        });
        Object.defineProperty(this, "documentVariableName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "context"
        });
        this.llmChain = fields.llmChain;
        this.documentVariableName =
            (_a = fields.documentVariableName) !== null && _a !== void 0 ? _a : this.documentVariableName;
        this.inputKey = (_b = fields.inputKey) !== null && _b !== void 0 ? _b : this.inputKey;
        this.outputKey = (_c = fields.outputKey) !== null && _c !== void 0 ? _c : this.outputKey;
    }
    async _call(values) {
        if (!(this.inputKey in values)) {
            throw new Error(`Document key ${this.inputKey} not found.`);
        }
        const { [this.inputKey]: docs, ...rest } = values;
        const texts = docs.map(({ pageContent }) => pageContent);
        const text = texts.join("\n\n");
        const result = await this.llmChain.call({
            ...rest,
            [this.documentVariableName]: text,
        });
        return result;
    }
    _chainType() {
        return "stuff_documents_chain";
    }
    static async deserialize(data) {
        const SerializedLLMChain = (0, util_1.resolveConfigFromFile)("llm_chain", data);
        return new StuffDocumentsChain({
            llmChain: await index_1.LLMChain.deserialize(SerializedLLMChain),
        });
    }
    serialize() {
        return {
            _type: this._chainType(),
            llm_chain: this.llmChain.serialize(),
        };
    }
}
exports.StuffDocumentsChain = StuffDocumentsChain;
/**
 * Chain that combines documents by stuffing into context.
 * @augments BaseChain
 * @augments StuffDocumentsChainInput
 */
class MapReduceDocumentsChain extends index_1.BaseChain {
    get inputKeys() {
        return [this.inputKey, ...this.combineDocumentChain.inputKeys];
    }
    constructor(fields) {
        var _a, _b, _c, _d, _e;
        super();
        Object.defineProperty(this, "llmChain", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "inputKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "input_documents"
        });
        Object.defineProperty(this, "outputKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "output_text"
        });
        Object.defineProperty(this, "documentVariableName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "context"
        });
        Object.defineProperty(this, "maxTokens", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 3000
        });
        Object.defineProperty(this, "maxIterations", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 10
        });
        Object.defineProperty(this, "combineDocumentChain", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.llmChain = fields.llmChain;
        this.combineDocumentChain = fields.combineDocumentChain;
        this.documentVariableName =
            (_a = fields.documentVariableName) !== null && _a !== void 0 ? _a : this.documentVariableName;
        this.inputKey = (_b = fields.inputKey) !== null && _b !== void 0 ? _b : this.inputKey;
        this.outputKey = (_c = fields.outputKey) !== null && _c !== void 0 ? _c : this.outputKey;
        this.maxTokens = (_d = fields.maxTokens) !== null && _d !== void 0 ? _d : this.maxTokens;
        this.maxIterations = (_e = fields.maxIterations) !== null && _e !== void 0 ? _e : this.maxIterations;
    }
    async _call(values) {
        if (!(this.inputKey in values)) {
            throw new Error(`Document key ${this.inputKey} not found.`);
        }
        const { [this.inputKey]: docs, ...rest } = values;
        let currentDocs = docs;
        for (let i = 0; i < this.maxIterations; i += 1) {
            const inputs = currentDocs.map((d) => ({
                [this.documentVariableName]: d.pageContent,
                ...rest,
            }));
            const length = inputs
                .map((i) => this.llmChain.llm.getNumTokens(this.llmChain.prompt.format(i)))
                .reduce((a, b) => a + b, 0);
            if (length < this.maxTokens) {
                break;
            }
            const results = await this.llmChain.apply(inputs);
            const { outputKey } = this.llmChain;
            currentDocs = results.map((r) => ({
                pageContent: r[outputKey],
            }));
        }
        const newInputs = { input_documents: currentDocs, ...rest };
        const result = await this.combineDocumentChain.call(newInputs);
        return result;
    }
    _chainType() {
        return "map_reduce_documents_chain";
    }
    static async deserialize(data) {
        const SerializedLLMChain = (0, util_1.resolveConfigFromFile)("llm_chain", data);
        const SerializedCombineDocumentChain = (0, util_1.resolveConfigFromFile)("combine_document_chain", data);
        return new MapReduceDocumentsChain({
            llmChain: await index_1.LLMChain.deserialize(SerializedLLMChain),
            combineDocumentChain: await index_1.BaseChain.deserialize(SerializedCombineDocumentChain),
        });
    }
    serialize() {
        return {
            _type: this._chainType(),
            llm_chain: this.llmChain.serialize(),
            combine_document_chain: this.combineDocumentChain.serialize(),
        };
    }
}
exports.MapReduceDocumentsChain = MapReduceDocumentsChain;
//# sourceMappingURL=combine_docs_chain.js.map