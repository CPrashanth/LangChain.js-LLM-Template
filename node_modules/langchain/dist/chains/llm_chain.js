"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConversationChain = exports.LLMChain = void 0;
const index_1 = require("./index");
const llms_1 = require("../llms");
const memory_1 = require("../memory");
const prompts_1 = require("../prompts");
const util_1 = require("../util");
/**
 * Chain to run queries against LLMs.
 * @augments BaseChain
 * @augments LLMChainInput
 *
 * @example
 * ```ts
 * import { LLMChain, OpenAI, PromptTemplate } from "langchain";
 * const prompt = PromptTemplate.fromTemplate("Tell me a {adjective} joke");
 * const llm = LLMChain({ llm: new OpenAI(), prompt });
 * ```
 */
class LLMChain extends index_1.BaseChain {
    get inputKeys() {
        return this.prompt.inputVariables;
    }
    constructor(fields) {
        var _a;
        super(fields.memory);
        Object.defineProperty(this, "prompt", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "llm", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "outputKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "text"
        });
        this.prompt = fields.prompt;
        this.llm = fields.llm;
        this.outputKey = (_a = fields.outputKey) !== null && _a !== void 0 ? _a : this.outputKey;
    }
    async _call(values) {
        let stop;
        if ("stop" in values && Array.isArray(values.stop)) {
            stop = values.stop;
        }
        const formattedString = this.prompt.format(values);
        const llmResult = await this.llm.call(formattedString, stop);
        const result = { [this.outputKey]: llmResult };
        return result;
    }
    /**
     * Format prompt with values and pass to LLM
     *
     * @param values - keys to pass to prompt template
     * @returns Completion from LLM.
     *
     * @example
     * ```ts
     * llm.predict({ adjective: "funny" })
     * ```
     */
    async predict(values) {
        const output = await this.call(values);
        return output[this.outputKey];
    }
    _chainType() {
        return "llm_chain";
    }
    static async deserialize(data) {
        const serializedLLM = (0, util_1.resolveConfigFromFile)("llm", data);
        const serializedPrompt = (0, util_1.resolveConfigFromFile)("prompt", data);
        return new LLMChain({
            llm: await llms_1.BaseLLM.deserialize(serializedLLM),
            prompt: await prompts_1.BasePromptTemplate.deserialize(serializedPrompt),
        });
    }
    serialize() {
        return {
            _type: this._chainType(),
            llm: this.llm.serialize(),
            prompt: this.prompt.serialize(),
        };
    }
}
exports.LLMChain = LLMChain;
// eslint-disable-next-line max-len
const defaultTemplate = `The following is a friendly conversation between a human and an AI. The AI is talkative and provides lots of specific details from its context. If the AI does not know the answer to a question, it truthfully says it does not know.

Current conversation:
{history}
Human: {input}
AI:`;
const defaultPrompt = new prompts_1.PromptTemplate({
    template: defaultTemplate,
    inputVariables: ["history", "input"],
});
class ConversationChain extends LLMChain {
    constructor(fields) {
        var _a, _b, _c;
        super({
            prompt: (_a = fields.prompt) !== null && _a !== void 0 ? _a : defaultPrompt,
            llm: fields.llm,
            outputKey: (_b = fields.outputKey) !== null && _b !== void 0 ? _b : "response",
        });
        this.memory = (_c = fields.memory) !== null && _c !== void 0 ? _c : new memory_1.BufferMemory();
    }
}
exports.ConversationChain = ConversationChain;
//# sourceMappingURL=llm_chain.js.map