"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VectorDBQAChain = void 0;
const index_1 = require("./index");
const util_1 = require("../util");
class VectorDBQAChain extends index_1.BaseChain {
    get inputKeys() {
        return [this.inputKey];
    }
    constructor(fields) {
        var _a, _b, _c;
        super();
        Object.defineProperty(this, "k", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 4
        });
        Object.defineProperty(this, "inputKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "query"
        });
        Object.defineProperty(this, "outputKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "result"
        });
        Object.defineProperty(this, "vectorstore", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "combineDocumentsChain", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.vectorstore = fields.vectorstore;
        this.combineDocumentsChain = fields.combineDocumentsChain;
        this.inputKey = (_a = fields.inputKey) !== null && _a !== void 0 ? _a : this.inputKey;
        this.outputKey = (_b = fields.outputKey) !== null && _b !== void 0 ? _b : this.outputKey;
        this.k = (_c = fields.k) !== null && _c !== void 0 ? _c : this.k;
    }
    async _call(values) {
        if (!(this.inputKey in values)) {
            throw new Error(`Question key ${this.inputKey} not found.`);
        }
        const question = values[this.inputKey];
        const docs = await this.vectorstore.similaritySearch(question, this.k);
        const inputs = { question, input_documents: docs };
        const result = await this.combineDocumentsChain.call(inputs);
        return result;
    }
    _chainType() {
        return "vector_db_qa";
    }
    static async deserialize(data, values) {
        if (!("vectorstore" in values)) {
            throw new Error(`Need to pass in a vectorstore to deserialize VectorDBQAChain`);
        }
        const { vectorstore } = values;
        const serializedCombineDocumentsChain = (0, util_1.resolveConfigFromFile)("combine_documents_chain", data);
        return new VectorDBQAChain({
            combineDocumentsChain: await index_1.BaseChain.deserialize(serializedCombineDocumentsChain),
            k: data.k,
            vectorstore,
        });
    }
    serialize() {
        return {
            _type: this._chainType(),
            combine_documents_chain: this.combineDocumentsChain.serialize(),
            k: this.k,
        };
    }
    static fromLLM(llm, vectorstore) {
        const qaChain = (0, index_1.loadQAChain)(llm);
        const instance = new this({ vectorstore, combineDocumentsChain: qaChain });
        return instance;
    }
}
exports.VectorDBQAChain = VectorDBQAChain;
//# sourceMappingURL=vector_db_qa.js.map