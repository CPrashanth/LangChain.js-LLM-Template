"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseChain = void 0;
const deepcopy = require("deepcopy");
const index_1 = require("./index");
const chainClasses = [
    index_1.LLMChain,
    index_1.StuffDocumentsChain,
    index_1.VectorDBQAChain,
    index_1.ChatVectorDBQAChain,
    index_1.MapReduceDocumentsChain,
    index_1.AnalyzeDocumentChain,
];
/**
 * Base interface that all chains must implement.
 */
class BaseChain {
    constructor(memory) {
        Object.defineProperty(this, "memory", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.memory = memory;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async run(input) {
        const isKeylessInput = this.inputKeys.length === 1;
        if (!isKeylessInput) {
            throw new Error(`Chain ${this._chainType()} expects multiple inputs, cannot use 'run' `);
        }
        const values = { [this.inputKeys[0]]: input };
        return this.call(values);
    }
    /**
     * Run the core logic of this chain and add to output if desired.
     *
     * Wraps {@link _call} and handles memory.
     */
    async call(values) {
        const fullValues = deepcopy(values);
        if (!(this.memory == null)) {
            const newValues = await this.memory.loadMemoryVariables(values);
            for (const [key, value] of Object.entries(newValues)) {
                fullValues[key] = value;
            }
        }
        // TODO(sean) add callback support
        const outputValues = this._call(fullValues);
        if (!(this.memory == null)) {
            await this.memory.saveContext(values, outputValues);
        }
        return outputValues;
    }
    /**
     * Call the chain on all inputs in the list
     */
    async apply(inputs) {
        return Promise.all(inputs.map(async (i) => this.call(i)));
    }
    /**
     * Load a chain from a json-like object describing it.
     */
    static deserialize(data, values = {}) {
        switch (data._type) {
            case "llm_chain":
                return index_1.LLMChain.deserialize(data);
            case "stuff_documents_chain":
                return index_1.StuffDocumentsChain.deserialize(data);
            case "vector_db_qa":
                return index_1.VectorDBQAChain.deserialize(data, values);
            default:
                throw new Error(`Invalid prompt type in config: ${data._type}`);
        }
    }
}
exports.BaseChain = BaseChain;
//# sourceMappingURL=base.js.map