"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a, _b;
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadFromHub = void 0;
const path_1 = __importDefault(require("path"));
const os_1 = __importDefault(require("os"));
const fs_1 = __importDefault(require("fs"));
const index_1 = require("./index");
const HUB_PATH_REGEX = /lc(@[^:]+)?:\/\/(.*)/;
const DEFAULT_REF = (_a = process.env.LANGCHAIN_HUB_DEFAULT_REF) !== null && _a !== void 0 ? _a : "master";
const URL_BASE = (_b = process.env.LANGCHAIN_HUB_URL_BASE) !== null && _b !== void 0 ? _b : "https://raw.githubusercontent.com/hwchase17/langchain-hub/";
const URL_PATH_SEPARATOR = "/";
const loadFromHub = async (uri, loader, validPrefix, validSuffixes, values = {}) => {
    const match = uri.match(HUB_PATH_REGEX);
    if (!match) {
        return undefined;
    }
    const [rawRef, remotePath] = match.slice(1);
    const ref = rawRef ? rawRef.slice(1) : DEFAULT_REF;
    const parts = remotePath.split(URL_PATH_SEPARATOR);
    if (parts[0] !== validPrefix) {
        return undefined;
    }
    if (!validSuffixes.has(path_1.default.extname(remotePath).slice(1))) {
        throw new Error("Unsupported file type.");
    }
    const url = [URL_BASE, ref, remotePath].join("/");
    const res = await (0, index_1.fetchWithTimeout)(url, { timeout: 5000 });
    if (res.status !== 200) {
        throw new Error(`Could not find file at ${url}`);
    }
    const text = await res.text();
    const tmpdir = fs_1.default.mkdtempSync(path_1.default.join(os_1.default.tmpdir(), "langchain"));
    const file = path_1.default.join(tmpdir, path_1.default.basename(remotePath.replace(URL_PATH_SEPARATOR, path_1.default.sep)));
    fs_1.default.writeFileSync(file, text);
    return loader(file, values);
};
exports.loadFromHub = loadFromHub;
//# sourceMappingURL=hub.js.map