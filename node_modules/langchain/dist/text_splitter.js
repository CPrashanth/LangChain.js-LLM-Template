"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenTextSplitter = exports.RecursiveCharacterTextSplitter = exports.CharacterTextSplitter = exports.TextSplitter = void 0;
const document_1 = require("./document");
class TextSplitter {
    constructor(fields) {
        var _a, _b;
        Object.defineProperty(this, "chunkSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 1000
        });
        Object.defineProperty(this, "chunkOverlap", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 200
        });
        this.chunkSize = (_a = fields === null || fields === void 0 ? void 0 : fields.chunkSize) !== null && _a !== void 0 ? _a : this.chunkSize;
        this.chunkOverlap = (_b = fields === null || fields === void 0 ? void 0 : fields.chunkOverlap) !== null && _b !== void 0 ? _b : this.chunkOverlap;
        if (this.chunkOverlap >= this.chunkSize) {
            throw new Error("Cannot have chunkOverlap >= chunkSize");
        }
    }
    createDocuments(texts, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    metadatas = []) {
        const _metadatas = metadatas.length > 0 ? metadatas : new Array(texts.length).fill({});
        const documents = new Array();
        for (let i = 0; i < texts.length; i += 1) {
            const text = texts[i];
            for (const chunk of this.splitText(text)) {
                documents.push(new document_1.Document({ pageContent: chunk, metadata: _metadatas[i] }));
            }
        }
        return documents;
    }
    splitDocuments(documents) {
        const texts = documents.map((doc) => doc.pageContent);
        const metadatas = documents.map((doc) => doc.metadata);
        return this.createDocuments(texts, metadatas);
    }
    joinDocs(docs, separator) {
        const text = docs.join(separator).trim();
        return text === "" ? null : text;
    }
    mergeSplits(splits, separator) {
        const docs = [];
        const currentDoc = [];
        let total = 0;
        for (const d of splits) {
            const _len = d.length;
            if (total + _len >= this.chunkSize) {
                if (total > this.chunkSize) {
                    console.warn(`Created a chunk of size ${total}, +
which is longer than the specified ${this.chunkSize}`);
                }
                if (currentDoc.length > 0) {
                    const doc = this.joinDocs(currentDoc, separator);
                    if (doc !== null) {
                        docs.push(doc);
                    }
                    // Keep on popping if:
                    // - we have a larger chunk than in the chunk overlap
                    // - or if we still have any chunks and the length is long
                    while (total > this.chunkOverlap ||
                        (total + _len > this.chunkSize && total > 0)) {
                        total -= currentDoc[0].length;
                        currentDoc.shift();
                    }
                }
            }
            currentDoc.push(d);
            total += _len;
        }
        const doc = this.joinDocs(currentDoc, separator);
        if (doc !== null) {
            docs.push(doc);
        }
        return docs;
    }
}
exports.TextSplitter = TextSplitter;
class CharacterTextSplitter extends TextSplitter {
    constructor(fields) {
        var _a;
        super(fields);
        Object.defineProperty(this, "separator", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "\n\n"
        });
        this.separator = (_a = fields === null || fields === void 0 ? void 0 : fields.separator) !== null && _a !== void 0 ? _a : this.separator;
    }
    splitText(text) {
        // First we naively split the large input into a bunch of smaller ones.
        let splits;
        if (this.separator) {
            splits = text.split(this.separator);
        }
        else {
            splits = text.split("");
        }
        return this.mergeSplits(splits, this.separator);
    }
}
exports.CharacterTextSplitter = CharacterTextSplitter;
class RecursiveCharacterTextSplitter extends TextSplitter {
    constructor(fields) {
        var _a;
        super(fields);
        Object.defineProperty(this, "separators", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: ["\n\n", "\n", " ", ""]
        });
        this.separators = (_a = fields === null || fields === void 0 ? void 0 : fields.separators) !== null && _a !== void 0 ? _a : this.separators;
    }
    splitText(text) {
        const finalChunks = [];
        // Get appropriate separator to use
        let separator = this.separators[this.separators.length - 1];
        for (const s of this.separators) {
            if (s === "") {
                separator = s;
                break;
            }
            if (text.includes(s)) {
                separator = s;
                break;
            }
        }
        // Now that we have the separator, split the text
        let splits;
        if (separator) {
            splits = text.split(separator);
        }
        else {
            splits = text.split("");
        }
        // Now go merging things, recursively splitting longer texts.
        let goodSplits = [];
        for (const s of splits) {
            if (s.length < this.chunkSize) {
                goodSplits.push(s);
            }
            else {
                if (goodSplits.length) {
                    const mergedText = this.mergeSplits(goodSplits, separator);
                    finalChunks.push(...mergedText);
                    goodSplits = [];
                }
                const otherInfo = this.splitText(s);
                finalChunks.push(...otherInfo);
            }
        }
        if (goodSplits.length) {
            const mergedText = this.mergeSplits(goodSplits, separator);
            finalChunks.push(...mergedText);
        }
        return finalChunks;
    }
}
exports.RecursiveCharacterTextSplitter = RecursiveCharacterTextSplitter;
/**
 * Implementation of splitter which looks at tokens.
 */
class TokenTextSplitter extends TextSplitter {
    constructor(fields) {
        var _a, _b, _c;
        super(fields);
        Object.defineProperty(this, "encodingName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "allowedSpecial", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "disallowedSpecial", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "tokenizer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.encodingName = (_a = fields === null || fields === void 0 ? void 0 : fields.encodingName) !== null && _a !== void 0 ? _a : "gpt2";
        this.allowedSpecial = (_b = fields === null || fields === void 0 ? void 0 : fields.allowedSpecial) !== null && _b !== void 0 ? _b : new Set();
        this.disallowedSpecial = (_c = fields === null || fields === void 0 ? void 0 : fields.disallowedSpecial) !== null && _c !== void 0 ? _c : "all";
        if ((fields === null || fields === void 0 ? void 0 : fields.allowedSpecial) != null) {
            throw new Error("allowedSpecial is not implemented yet.");
        }
        if ((fields === null || fields === void 0 ? void 0 : fields.disallowedSpecial) != null) {
            throw new Error("disallowedSpecial is not implemented yet.");
        }
        try {
            const tiktoken = 
            // eslint-disable-next-line @typescript-eslint/no-var-requires, global-require
            require("@dqbd/tiktoken");
            this.tokenizer = tiktoken.get_encoding(this.encodingName);
        }
        catch (err) {
            console.error(err);
            throw new Error("Please install @dqbd/tiktoken as a dependency with, e.g. `npm install -S @dqbd/tiktoken`");
        }
    }
    splitText(text) {
        const splits = [];
        const input_ids = this.tokenizer.encode(text);
        let start_idx = 0;
        let cur_idx = Math.min(start_idx + this.chunkSize, input_ids.length);
        let chunk_ids = input_ids.slice(start_idx, cur_idx);
        const decoder = new TextDecoder();
        while (start_idx < input_ids.length) {
            splits.push(decoder.decode(this.tokenizer.decode(chunk_ids)));
            start_idx += this.chunkSize - this.chunkOverlap;
            cur_idx = Math.min(start_idx + this.chunkSize, input_ids.length);
            chunk_ids = input_ids.slice(start_idx, cur_idx);
        }
        return splits;
    }
}
exports.TokenTextSplitter = TokenTextSplitter;
//# sourceMappingURL=text_splitter.js.map