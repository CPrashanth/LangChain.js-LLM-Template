"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BasePromptTemplate = void 0;
const index_1 = require("./index");
const templateClasses = [index_1.PromptTemplate, index_1.FewShotPromptTemplate];
/**
 * Base class for prompt templates. Exposes a format method that returns a
 * string prompt given a set of input values.
 * @augments BasePromptTemplateInput
 */
class BasePromptTemplate {
    constructor(input) {
        Object.defineProperty(this, "inputVariables", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "outputParser", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        const { inputVariables } = input;
        if (inputVariables.includes("stop")) {
            throw new Error("Cannot have an input variable named 'stop', as it is used internally, please rename.");
        }
        Object.assign(this, input);
    }
    /**
     * Load a prompt template from a json-like object describing it.
     *
     * @remarks
     * Deserializing needs to be async because templates (e.g. {@link FewShotPromptTemplate}) can
     * reference remote resources that we read asynchronously with a web
     * request.
     */
    static async deserialize(data) {
        switch (data._type) {
            case "prompt":
                return index_1.PromptTemplate.deserialize(data);
            case undefined:
                return index_1.PromptTemplate.deserialize({ ...data, _type: "prompt" });
            case "few_shot":
                return index_1.FewShotPromptTemplate.deserialize(data);
            default:
                throw new Error(`Invalid prompt type in config: ${data._type}`);
        }
    }
}
exports.BasePromptTemplate = BasePromptTemplate;
//# sourceMappingURL=base.js.map